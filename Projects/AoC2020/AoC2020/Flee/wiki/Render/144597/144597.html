<div class="wikidoc"><b>Frequently Asked Questions</b><br /><br /><b>When I create an expression such as <span class="codeInline">1/2</span>, why is the result 0 instead of 0.5?</b><br />When an arithmetic operation involves two integers, the result will be an integer.  If either or both operands are floating-point, then the result will be floating-point.  In the above case, since both operands are integers, an integer division is performed and yields 0.  This is a performance feature which makes sure that expressions that perform arithmetic involving only integers will use the more efficient and faster integer instructions.<br /><br />Workarounds:
<ul><li>Make either operand a real number: 1/2.0 or 1.0/2</li>
<li>Use the <span class="codeInline">ExpressionOptions.IntegersAsDoubles</span> option to force Flee to treat all integer literals as doubles.  With this option set, <span class="codeInline">1/2</span> will evaluate to 0.5.</li></ul>
<br /><b>Why do I get compile exceptions when I call functions with multiple real number arguments and my culture uses &#39;,&#39; as the decimal separator (ie: sum(1,23, 4,56))?</b><br />When the decimal separator for real numbers is set to &#39;,&#39;, Flee has to use a different character as the argument delimiter for functions otherwise the grammar becomes ambiguous.  To avoid the ambiguity, Flee uses the list separator character from the parse culture as the delimiter for function arguments.<br /><br />Example:<br />en-US: <span class="codeInline">sum(1.23, 4.56)</span><br />fr-FR: <span class="codeInline">sum(1,23; 4,56)</span><br /><br />If you really want to use &#39;,&#39; for both the decimal separator and function arguments, you can set the <span class="codeInline">ExpressionContext.ParserOptions.RequireDigitsBeforeDecimalPoint</span> property to true.  This will require all real numbers to have a digit before the decimal point (ie: 0.45 instead of .45) but will eliminate the grammar ambiguity.</div><div class="ClearBoth"></div>