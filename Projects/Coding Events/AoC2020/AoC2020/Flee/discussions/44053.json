[
  {
    "Id": "146545",
    "ThreadId": "44053",
    "Html": "Hi eugene, <br>\r\nI Using the Expression Evaluator for a Custom Evaluation Engine for Payroll Formulas.I Have 1355 payroll (Formulas/and/or Variables) <br>\r\n<br>\r\n<strong>When I Load the Data For The Formulas/Variables from SQL Server Database and Create The variables/and Formulas and Evaluate them.<br>\r\n The Elapsed Time is about 16 seconds mainly because of</strong><span style=\"font-size:13px;color:#0000ff\">   Dim</span><span style=\"font-size:13px\"> e </span><span style=\"font-size:13px;color:#0000ff\">As</span><span style=\"font-size:13px\"> IGenericExpression(</span><span style=\"font-size:13px;color:#0000ff\">Of</span><span style=\"font-size:13px\"> </span><span style=\"font-size:13px;color:#0000ff\">Double</span><span style=\"font-size:13px\">) = context.CompileGeneric(</span><span style=\"font-size:13px;color:#0000ff\">Of</span><span style=\"font-size:13px\"> </span><span style=\"font-size:13px;color:#0000ff\">Double</span><span style=\"font-size:13px\">)(oValue.ToString())   </span>\r\n<p> </p>\r\n<p><strong>Then in subsecuent evaluations (changing only the variables and reevaluate the formulas), the elapsed time is about .38 seconds for the 1355 formulas<br>\r\n</strong><br>\r\n The Big Questions are:<br>\r\n   1) <strong>How I can Reduce the Time of 16 seconds During the Creation/Setup of the Formulas by the expression Evaluator.<br>\r\n</strong>      (I noticed that for each of the formulas/variables it adds up to the Expression.dll in memory),<br>\r\n   2) <strong>Is there any way to add all the expressions(1355) at once to the Expression.dll in memory</strong>?, Thus reducing the <br>\r\n       Initital Creation FormulaCreation Time of 16 seconds?<br>\r\n   <br>\r\n     Any toughts are welcome<br>\r\n<br>\r\n FYI:<br>\r\n   I'm not using your Batch loader Class Because:<br>\r\n    1) it does the Natural order of recalcuation and might degrade the performance for the Evaluation of the formulas.<br>\r\n    2) When Im loading the data from the SQL server I load it in the natural order of recalculation(so i don't need to<br>\r\n         tag a reference to the evaluation result of a formula be tagged with $ ie :    <span style=\"font-size:13px\">loader.Add(</span><span style=\"font-size:13px;color:#800000\">&quot;b&quot;</span><span style=\"font-size:13px\">, </span><span style=\"font-size:13px;color:#800000\">&quot;$a + 1 + $a&quot;</span><span style=\"font-size:13px\">, context)<br>\r\n</span>         (imagine manually tagging the 1355 formulas !!! no way)<br>\r\n<br>\r\n   Best Regards<br>\r\n   Arturo Ruvalcaba<br>\r\n<br>\r\n<br>\r\n<br>\r\n<br>\r\n   <br>\r\n   <br>\r\n  </p>\r\n<p> </p>\r\n",
    "PostedDate": "2009-01-12T20:33:00.197-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "146553",
    "ThreadId": "44053",
    "Html": "Eugene,<br>\r\n Never Mind, I figured Out, I have to tell Flee to not to generate an assembly to a disk file with<br>\r\n<span style=\"font-size:13px\">   options.EmitToAssembly = </span><span style=\"font-size:13px;color:#0000ff\">False   ' to create the assembly in memory   <br>\r\n<p> </p>\r\n<p> </p>\r\n</span>\r\n<p> Awesome Library I'ts 1000 zillion times faster than your Excel Like Formula Engine<br>\r\n<br>\r\nBest Regards, From Mexico,<br>\r\nKeep the good work<br>\r\nArturo Ruvalcaba<br>\r\n<br>\r\n   any way tought you guys wanted to see some Stats for evaluation pourposes: <br>\r\n  1) Formulas and variables                                                 : 1344 <br>\r\n  2) Time to create Formulas and Variables (compile them) : 1.76 seconds <br>\r\n  3) Compilation Method                                                    : Dim e As IGenericExpression(Of Double) = context.CompileGeneric(Of Double)(oValue.ToString()) <br>\r\n  4) Speed                                                                          : 766 evaluations per second <br>\r\n<br>\r\n  reevaluations :<br>\r\n  1) Time to re evaluate Formulas and Variables  : 0.37 seconds <br>\r\n  2) Speed                                                                          : 3652 evaluations per second <br>\r\n  <br>\r\n  It would be nicer If  I could paste the screenshoot <br>\r\n   <strong>:&gt;) </strong><br>\r\n<br>\r\n<br>\r\n<br>\r\n  <br>\r\n<br>\r\n  </p>\r\n",
    "PostedDate": "2009-01-12T21:21:58.943-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "146751",
    "ThreadId": "44053",
    "Html": "Hi Arturo,<br>\r\n<br>\r\nGlad you like the library.<br>\r\n<br>\r\n&gt;Never Mind, I figured Out,&nbsp;I have to&nbsp;tell Flee to&nbsp;not to generate an assembly to a disk file with<br>\r\n&gt;<span style=\"font-size:13px\">&nbsp;&nbsp; options.EmitToAssembly = </span><span style=\"font-size:13px;color:rgb(0, 0, 255)\">False&nbsp;&nbsp; ' to create the assembly in memory&nbsp;&nbsp; </span><br>\r\nThe EmitToAssembly functionality is mostly meant to be a diagnostic tool: it makes Flee emit its IL to an assembly so that you can view it with a disassembler.<br>\r\n<br>\r\n&gt; I'm&nbsp;not using your&nbsp;Batch loader&nbsp;Class<br>\r\nYeah, the calc engine needs refactoring.&nbsp; The first thing that needs to be done is eliminate the need to reference other expressions with a '$'.&nbsp; I'm also not sure how useful the calc engine is to people so I don't want to spend a lot of effort on a feature that nobody uses.&nbsp; What do you think?<br>\r\n",
    "PostedDate": "2009-01-13T10:26:29.75-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "146918",
    "ThreadId": "44053",
    "Html": "  Maybe,<br>\r\n  the calc engine is fine like it is, it's fine for evaluating formulas like in a spreadsheet context when you have a bunch <br>\r\n  of formulas all spread around a like in a excel spreadsheet (as in your excel formula engine).<br>\r\n<br>\r\n  But in my case I already have the expressions/variables in natural order of recalcuation, as Im <br>\r\n  Using the expressions/formulas from an shrink wrap app, And using them in an payroll app that im<br>\r\n  developing for the Mexican Payrolls (personal project for late nights work is geting to boring <strong>:&gt;)</strong>. Any way. <br>\r\n  <br>\r\n  The calc engine could be ok as it is, But i'm wondering if you could create another class with out <br>\r\n  1)  the natural order of recalculation (topological sort) <br>\r\n  2)  the access to the other expressions with the $ <br>\r\n  but still being able to use the batch loader class with the new class. so it will be simpler to use and will maybe have <br>\r\n  better performance because of 1) and 2) overhead is eliminated particulary<br>\r\n <br>\r\n  Does this make sense? or im asking to much?, and the performance gains for this new class will be worth it and <br>\r\n  noticeable for volumes of 1000 or more expressions/formulas<br>\r\n<br>\r\n  well, <br>\r\n  thats what I think,  letme know what you think.<br>\r\n<br>\r\n  Best Regards,<br>\r\n  and Late happy new year :&gt;)<br>\r\n  <br>\r\n  Arturo Ruvalcaba<br>\r\n<br>\r\n<br>\r\n<br>\r\n<br>\r\n   <br>\r\n  <br>\r\n  \r\n",
    "PostedDate": "2009-01-13T23:15:11.7-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "147538",
    "ThreadId": "44053",
    "Html": "Your idea is a simpler version of the calc engine.&nbsp; If the expressions being loaded are assumed to be in natural order, then resolving expressions is much simpler and the '$' is not required.<br>\r\n<br>\r\nWhen an expression references another expression, the engine will add the referenced expression as a variable to the parent expression.&nbsp; Once all the expressions are loaded, you could do something like the following:\r\n<pre>double result = calcEngine.GetResult&lt;double&gt;(&quot;topLevel1&quot;);</pre>\r\nwhich would evaluate the top-level expression, and in turn, evaluate all the lower level expressions to get the result.<br>\r\n<br>\r\nSo basically, the workflow would be:<br>\r\n<ul>\r\n    <li>Load the expressions into the engine</li>\r\n    <li>Get the results of all the expressions you are interested in</li>\r\n</ul>\r\nAm I close to what you have in mind?\r\n",
    "PostedDate": "2009-01-15T16:33:50.027-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "147598",
    "ThreadId": "44053",
    "Html": "Yes, I haven't tested, If I can do it what I need  with the Calc Engine with Out the &quot;$&quot; reference, I Might Try it later, but for now <br>\r\nI cook up a rough Payroll Engine like the code below<br>\r\n If Im not wrong. I made Public these:<br>\r\n  1) myPayrollEngine.vc.Values()<br>\r\n  2) myPayrollEngine.vc.Keys() <br>\r\n   <br>\r\n  Sorry for the long text (i shortened the LoadandEvaluateData proc and the builtin functions), but Might Be Intersting for others any way you might  get a better idea :&gt;)  <br>\r\n<p> Best Regards<br>\r\n Arturo Ruvalcaba<br>\r\n<br>\r\n{================Payroll Engine Evaluator Sample with Out &quot;$&quot; ========================}<br>\r\n<br>\r\nImports ciloci.Flee<br>\r\nImports System.Data.SqlClient</p>\r\n<p> Public Class frmPayroll<br>\r\n    Public blnFormulasCreated As Boolean<br>\r\n    Public myPayrollEngine As New PayrollEngine</p>\r\n<p>#Region &quot;Payroll Functions 57 Functions&quot;<br>\r\n    Public Class BuiltInFunctions<br>\r\n        Private XctnQty As Integer<br>\r\n        Public Shared Function _acumulado(ByVal prm1 As Integer) As Double<br>\r\n            Dim number As Double = 150<br>\r\n            Return number<br>\r\n        End Function<br>\r\n        Public Shared Function VPagoVacaciones(ByVal prm1 As Integer) As Integer<br>\r\n            Dim number As Integer = 150<br>\r\n            Return number<br>\r\n        End Function<br>\r\n        Public Shared Function FRAC(ByVal prm1 As Double) As Double<br>\r\n            Dim number As Double = 150<br>\r\n            Return number<br>\r\n        End Function<br>\r\n        Public Shared Function INT(ByVal prm1 As Double) As Integer<br>\r\n            Dim number As Integer = 150<br>\r\n            Return number<br>\r\n        End Function</p>\r\n<p>    End Class<br>\r\n#End Region</p>\r\n<p>    Public Class PayrollEngine<br>\r\n        ' Use same options for all expressions<br>\r\n        Public context As ExpressionContext<br>\r\n        Private options As ExpressionOptions<br>\r\n        Public vc As VariableCollection</p>\r\n<p>        Public SQLCnx As SqlConnection<br>\r\n        Public SQLCmd As SqlCommand<br>\r\n        Public cont As Integer = 0<br>\r\n        Private SQLDtR As SqlDataReader<br>\r\n        Private sVarName As String = &quot;&quot;<br>\r\n        Private sVarExpr As String = &quot;&quot;<br>\r\n        Private sStype As String = &quot;&quot;</p>\r\n<p>        Public Sub LoadPayrollInfo()<br>\r\n            context = New ExpressionContext()<br>\r\n            options = context.Options<br>\r\n            vc = context.Variables</p>\r\n<p>            options.IntegersAsDoubles = False<br>\r\n            options.EmitToAssembly = False<br>\r\n            ' Import math so we have access to its functions in expressions<br>\r\n            context.Imports.AddType(GetType(Math))<br>\r\n            context.Imports.AddType(GetType(BuiltInFunctions))</p>\r\n<p>            SQLCnx = New SqlConnection(&quot;Data Source=(local);Initial Catalog=Nomipaq;Integrated Security=SSPI;&quot;)<br>\r\n            SQLCmd = New SqlCommand<br>\r\n            SQLCmd.Connection = SQLCnx<br>\r\n            SQLCmd.CommandType = CommandType.Text<br>\r\n            SQLCnx.Open()</p>\r\n<p>            Me.LoadandEvaluateData(False)</p>\r\n<p>        End Sub</p>\r\n<p>        Public Sub LoadandEvaluateData(ByVal bShow As Boolean)<br>\r\n            '==============Load all Info and Formulas from database and evaluate them<br>\r\n            '===========================================================================<br>\r\n            Dim icnt As Integer<br>\r\n            Dim arr(20, 2) As String<br>\r\n            Dim elem As Integer<br>\r\n            Dim bnd As Boolean</p>\r\n<p>            arr(0, 0) = &quot;Select * from Nom10000 where IDEmpresa =3                          &quot; 'Company      SomeCompany<br>\r\n            arr(17, 0) = &quot;Select * from Nom10004 Where TipoConcepto = 'P' order by NumeroConcepto&quot; 'Payroll Concepts  P = Income<br>\r\n            arr(18, 0) = &quot;Select * from Nom10004 Where TipoConcepto = 'D' order by NumeroConcepto&quot; 'Payroll Concepts D = Withdrawals (Taxes for income)<br>\r\n            arr(19, 0) = &quot;Select * from Nom10004 Where TipoConcepto = 'O' order by NumeroConcepto&quot; 'Payroll Concepts O = Employeer Obligations (Taxes on behaf of employee)<br>\r\n            arr(20, 0) = &quot;Select * from Nom10004 Where TipoConcepto = 'N' order by NumeroConcepto&quot; 'Payroll Concepts N = Net Income<br>\r\n            arr(0, 1) = &quot;empresa&quot;<br>\r\n            arr(17, 1) = &quot;conceptos&quot;<br>\r\n            arr(18, 1) = &quot;conceptos&quot;<br>\r\n            arr(19, 1) = &quot;conceptos&quot;<br>\r\n            arr(20, 1) = &quot;conceptos&quot;<br>\r\n            sVarName = &quot;_0&quot;<br>\r\n            bnd = DoAdd(&quot;Var&quot;, 0)<br>\r\n            For elem = 0 To 20<br>\r\n                If arr(elem, 1) &lt;&gt; &quot;&quot; Then<br>\r\n                    With SQLCmd<br>\r\n                        .CommandText = arr(elem, 0)<br>\r\n                        SQLDtR = .ExecuteReader()<br>\r\n                        If SQLDtR.HasRows = True Then<br>\r\n                            While SQLDtR.Read()<br>\r\n                                Dim ifld As Integer<br>\r\n                                If elem = 15 Then<br>\r\n                                End If<br>\r\n                                If arr(elem, 1) &lt;&gt; &quot;&quot; Then<br>\r\n                                    If arr(elem, 1) = &quot;conceptos&quot; Then<br>\r\n                                        For ifld = 19 To 23<br>\r\n                                            Select Case ifld<br>\r\n                                                Case 19 : icnt = 5<br>\r\n                                                Case 20 : icnt = 1<br>\r\n                                                Case 21 : icnt = 2<br>\r\n                                                Case 22 : icnt = 3<br>\r\n                                                Case 23 : icnt = 4<br>\r\n                                                    'Case 0: icnt = 6<br>\r\n                                            End Select</p>\r\n<p>                                            If icnt &gt; 0 Then<br>\r\n                                                sStype = SQLDtR.GetFieldType(ifld).ToString()<br>\r\n                                                If ifld &gt;= 0 Then<br>\r\n                                                    sVarName = &quot;_concepto_&quot; &amp; LCase(SQLDtR.GetValue(2).ToString) &amp; &quot;_&quot; &amp; SQLDtR.GetValue(0).ToString &amp; &quot;_&quot; &amp; icnt.ToString<br>\r\n                                                    sVarExpr = IIf(SQLDtR.GetValue(ifld) Is DBNull.Value, 0, SQLDtR.GetValue(ifld))<br>\r\n                                                    If (SQLDtR.GetValue(ifld) Is DBNull.Value) Then<br>\r\n                                                        bnd = DoAdd(&quot;Var&quot;, CDbl(0))<br>\r\n                                                    Else<br>\r\n                                                        sVarExpr = SQLDtR.GetValue(ifld).ToString<br>\r\n                                                        bnd = DoAdd(&quot;Exp&quot;, New String(sVarExpr))<br>\r\n                                                    End If<br>\r\n                                                End If<br>\r\n                                            End If<br>\r\n                                        Next ifld<br>\r\n                            End While<br>\r\n                        End If<br>\r\n                    End With<br>\r\n                    SQLDtR.Close()<br>\r\n                End If<br>\r\n            Next elem<br>\r\n            frmPayroll.blnFormulasCreated = True<br>\r\n        End Sub<br>\r\n        Private Function DoAdd(ByVal sKind As String, ByVal oValue As Object) As Boolean<br>\r\n            Dim Result As Object<br>\r\n            cont = cont + 1<br>\r\n            Dim x As Integer = 0<br>\r\n            If x = 0 Then<br>\r\n                If frmPayroll.blnFormulasCreated = False Then<br>\r\n                    If sKind = &quot;Exp&quot; Then<br>\r\n                        If oValue.GetType().FullName = &quot;System.String&quot; Then<br>\r\n                            oValue = oValue.ToString().Replace(&quot;IIF&quot;, &quot;if&quot;)<br>\r\n                            oValue = oValue.ToString().Replace(&quot;iif&quot;, &quot;if&quot;)<br>\r\n                        End If<br>\r\n                        Dim e As IGenericExpression(Of Double) = context.CompileGeneric(Of Double)(oValue.ToString())<br>\r\n                        vc.Add(sVarName, e)<br>\r\n                    Else<br>\r\n                        vc.Add(sVarName, oValue)<br>\r\n                    End If<br>\r\n                Else<br>\r\n                    If sKind = &quot;Exp&quot; Then<br>\r\n                        Result = CType(context.Variables.Item(sVarName), IGenericExpression(Of Double)).Evaluate()<br>\r\n                    Else<br>\r\n                        vc(sVarName) = oValue<br>\r\n                    End If<br>\r\n                End If<br>\r\n            End If<br>\r\n        End Function</p>\r\n<p>    End Class</p>\r\n<p>    Protected Overrides Sub OnLoad(ByVal e As System.EventArgs)<br>\r\n        MyBase.OnLoad(e)<br>\r\n        Me.blnFormulasCreated = False<br>\r\n    End Sub</p>\r\n<p>    Private Sub EvaluateFormulas_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles EvaluateFormulas.Click<br>\r\n        Dim sw As New Stopwatch()<br>\r\n        Dim seconds As Double<br>\r\n        Dim iEvalRun As Integer = 0<br>\r\n        sw.Start()<br>\r\n        myPayrollEngine.LoadPayrollInfo()<br>\r\n        sw.Stop()<br>\r\n        seconds = sw.ElapsedMilliseconds / 1000<br>\r\n        Dim NUM_EVALS As Integer = myPayrollEngine.cont<br>\r\n        Debug.Print(&quot;Evaluations: {1:n0}{0}Time: {2:n2} seconds{0}Speed: {3:n0} evaluations/sec&quot;, System.Environment.NewLine, NUM_EVALS, seconds, NUM_EVALS / seconds)<br>\r\n        Me.lblStatus.Text = String.Format(&quot;Evaluations: {1:n0}{0}Time: {2:n2} seconds{0}Speed: {3:n0} evaluations/sec&quot;, System.Environment.NewLine, NUM_EVALS, seconds, NUM_EVALS / seconds)<br>\r\n        For iEvalRun = 1 To 1<br>\r\n            sw.Reset()<br>\r\n            sw.Start()<br>\r\n            myPayrollEngine.LoadandEvaluateData(True)<br>\r\n            sw.Stop()<br>\r\n            seconds = sw.ElapsedMilliseconds / 1000<br>\r\n            Debug.Print(&quot;Evaluations: {1:n0}{0}Time: {2:n2} seconds{0}Speed: {3:n0} evaluations/sec&quot;, System.Environment.NewLine, NUM_EVALS, seconds, NUM_EVALS / seconds)<br>\r\n        Next iEvalRun<br>\r\n        myPayrollEngine.SQLCmd = Nothing<br>\r\n        myPayrollEngine.SQLCnx.Close()<br>\r\n        LoadNames()<br>\r\n    End Sub<br>\r\n    Private Sub LoadNames()<br>\r\n        ' Get the names of all named references with formulas in the engine and Put them in a DatagridView (Payroll Calculation Work Sheet)<br>\r\n        Dim retval As String<br>\r\n        Dim item As String<br>\r\n        Dim rowcnt As Integer = 0<br>\r\n        retval = &quot;&quot;<br>\r\n        DataGridView1.Rows.Clear()<br>\r\n        For Each item In TryCast(myPayrollEngine.vc.Keys(), System.Collections.Generic.ICollection(Of String))<br>\r\n            DataGridView1.Rows.Add()<br>\r\n            DataGridView1.Rows(rowcnt).Cells(1).Value = item<br>\r\n            DataGridView1.Rows(rowcnt).Cells(0).Value = rowcnt<br>\r\n            rowcnt = rowcnt + 1<br>\r\n        Next<br>\r\n        rowcnt = 0<br>\r\n        Dim item2 As Object<br>\r\n        Dim result As Double<br>\r\n        Dim sVARName As String<br>\r\n        For Each item2 In TryCast(myPayrollEngine.vc.Values(), System.Collections.Generic.ICollection(Of Object))<br>\r\n            DataGridView1.Rows(rowcnt).Cells(2).Value = item2.ToString()<br>\r\n            sVARName = DataGridView1.Rows(rowcnt).Cells(1).Value<br>\r\n            If myPayrollEngine.context.Variables.Item(sVARName).GetType().Name = &quot;Expression`1&quot; Then<br>\r\n                result = CType(myPayrollEngine.context.Variables.Item(sVARName), IGenericExpression(Of Double)).Evaluate()<br>\r\n                'Debug.Print(&quot;Type = {0} Value = {1}&quot;, context.Variables.Item(sVarName).GetType().Name, Result)<br>\r\n                DataGridView1.Rows(rowcnt).Cells(3).Value = result<br>\r\n            End If<br>\r\n            rowcnt = rowcnt + 1<br>\r\n        Next<br>\r\n        DataGridView1.Refresh()<br>\r\n    End Sub<br>\r\nEnd Class</p>\r\n",
    "PostedDate": "2009-01-15T21:45:13.897-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]